<설정 및 환경 관련>
* SDK Manager - Android SDK
    SDK Platform 설치 필요, SDK Tools의 Android Emulator, SDK Platform-Tools, SDK-Tools 필요.
    (특히, waiting for target device to come online 이 길어지면 확인해 볼 것.)

* Tools - Kotlin - Configure Kotlin Plugin Updates를 실행한 뒤 최신버전 과 build.gradle(project) 안의 ext.kotlin_version을 맞춰줘야한다.

* local.properties의 sdk.dir 자동으로 맞춰줌.

*dependecies에서 jre로 되어있는 것을 jdk로 변경한다.
implementation "org.jetbrains.kotlin:kotlin-stdlib-jre7:$kotlin_version => implementation "org.jetbrains.kotlin:kotlin-stdlib-jdk7:$kotlin_version
// 참고: https://tjandroid.blogspot.com/2018/11/api-implementation.html

* Gradle Dependency> compile -> implementation

* Package Name: Manifest 혹은 Gradle에서 설정가능 (Flavor로 b2b인지 b2c용인지 나눌 수 있다.)

<코딩 관련>

* Life Cycle은 어떤 동작이 필요한 시점에 특정 라이프 사이클 호출되어야 하는지가 중요하다.

* var 변수명:변수타입
* var(variable) VS val(valuable) 차이
 - var는 get/set가능한 일반 변수
 - val은 get만 가능한 상수

* ? - nullable 변수 선언시 사용한다. (예. container:ViewGroup?)
    - 코틀린엔 Non-null과 Nullable 타입이 존재함.

* C#은 하나의 코드에 designer가 포함되어 있어서 컴포넌트를 id로 바로 불러올 수 있지만
android는 화면xml을 import 해주어야 한다. ex) import kotlinx.android.synthetic.main.activity_login.*

* resource는 코드 내에선 R 객체로 접근한다. 화면에서는 @타입/name으로 찾는다.(@color/colorWhite)
    -> SetContentView가 선행으로 이루어야 FindViewById로 읽을 수 있음.    

* 디자인은 C#의 designer 처럼 xml text를 건드리지 않고 design의 attributes(C#에서는 properties)를 조절한다.

* Fragment는 Activity 안에 독립적으로 뜰 수 있는 화면

* Constraint Layout VS Relative Layout
 ConstraintLayout: 뷰의 수평적인 계층 구조, 성능도 빠름. => UI 배치의 편리함.
 RelativeLayout: 뷰들 간에 정렬을 위해 새로운 ViewGroup 생성 필요.

* Fragment -  하위 Activity로 봐도 무관함. 자체 생명주기를 가짐. 자체적으로 이벤트도 받음. 
              Fragment 클래스를 구현해야 사용가능 함. Fragment 자체 layout 또한 필요함.
              정적 추가: fragment, 동적 추가: FrameLayout

* Missing Constraints in ConstraintLayout Error - ConstraintLayout 안의 View들이 parent인 ConstraintLayout에 연결시켜야 한다.

* HTTP 통신 (POST 방식, 서울메트로에 요청)
 1. 라이브러리 khttp 사용하기 위해 app build에 'implementation group: 'khttp', name: 'khttp', version: '0.1.0'' 추가
 2. val policy = StrictMode.ThreadPolicy.Builder().permitAll().build() 선언 후 setThreadPolicy(policy) 선언 => android.os.strictmode$androidblockguardpolicy.onnetwork exception 발생
    - StrictMode는 메인 스레드에서 디스크/네트워크 접근 등의 비효율적인 작업을 하려는 것을 감지함. (속도가 느려질 수 있는 동작을 미리 감지 함.), 오래 걸릴 수 있는 작업을 Main Thread와 분리하여 Android Not Response 방지.
    - Callback, lifecycle 관련 등의 UI 이벤트 들은 모두 Main Thread에서 처리함.
    - 디스크 접근: 파편화된 블록 모으기 작업을 수행하는 동안 지연발생 가능성 + 다른 프로세스가 삭제 작업을 진행하면 다른 프로세스의 IO 작업이 지연 + 메모리 여유 공간이 적을 수록 IO 지연
    - 네트워크 접근: 예측 불가능 하므로 Main Thread에서 처리하면 안됨. (기본적으로 정책 적용됨)
    - Thread 정책을 모두 허용하는 정책(permitAll().build())으로 설정한다.(setThreadPolicy)
 3. AndroidManifest.xml 안에 <user-permission android:name="android.permission.INTERNET" /> 선언. =>  java.lang.SecurityException: Permission denied (missing INTERNET permission?) 발생
 4. POST 방식, Query String을 mapOf("Key1" to "Value2",...)로 선언하여 payload에 넣고, post(url = "", data = payload)을 실행하면 Response 객체로 온다.
 5. Reponse 객체의 text 값을 보면 결과 값이 xml 형태로 날라온 것을 알 수 있다.

  //참고: https://noota.tistory.com/entry/StrictMode-%EA%B0%84%EB%8B%A8-%EC%A0%95%EB%A6%AC, 
        https://khttp.readthedocs.io/en/latest/user/quickstart.html
 
* ListView : 모든 데이터에 대한 View를 만들고, View가 사라졌다가 나타날 때마다 리소스를 불러와야 함. (예. 화면을 아래로 스크롤 했다가 다시 위로 올릴 때 리소스 다시 불러옴.)
            -> 메모리와 저장 공간을 많이 사용하므로 비효율적            

* RecyclerView - ListView의 단점을 보완. (예. 300개의 dataSet이 있고 화면상에는 10개의 dataSet만 보여진다면 10개의 공간을 생성 후 그 공간을 재활용하여 300개를 보여준다.)
 1. 사용하기 위해 gradle에 추가한다.
 2. RecyclerView 를 layout에 선언한다. (id: mRecyclerView)
 3. RecyclerView에서 사용하는 항목 하나하나를 담당 할 item 뷰에 대한 xml도 추가한다.
 4. RecyclerView 를 위한 Activity를 생성한다.
 5. 어답터를 생성한다.
    Adapter : 데이터의 원본을 받아서 관리하고, View가 출력할 수 있는 형태로 데이터를 제공하는 중간 객체. 받은 데이터를 어떻게 보여줄지 정해주는 바인딩 역할의 객체라 보면 됨.
             어댑터와 연결된 원본 데이터가 변경되면, notifyDataSetChanged 메서드를 호출하여 화면에 다시 그려지도록 한다.
    ViewHolder : RecyclerView 내 위치하는 곳의 item view와 metadata 정보를 갖고있는 역할.
     => RecyclerView가 있고, 그 내부의 item view들에 data들을 binding 시켜주는 역할은 adapter가 전담한다.
        Adapter는 각 item view의 정보를 갖고 있는 ViewHolder를 이용해서 각각의 item view에 알맞은 data를 binding 시켜준다.
        그리고 LayoutManager가 각 item view들의 크기를 측정하고 위치를 지정하여 RecyclerView를 구성한다.

 6. mRecyclerView에 어답터를 붙인다.
 7. mRecyclerView에 해당하는 layoutManager를 붙인다. (mRecyclerView.layoutManager = LinearLayoutManager(applicationContext))
    LayoutManager : RecyclerView 내에 item View들의 크기를 측정하고 위치를 지정하고 언제 item View들을 재사용하는지에 대한 정책을 결정하는 역할.

 // 참고 : https://blog.naver.com/mail1001/220682221473

 * intent를 이용한 activity call
  1. intent를 선언한다. Intent (현재 액티비티, 전달할 액티비티) (예. Intent(this, RecyclerViewActivity::class.java))
  2. 전달할 데이터를 넣는다. intent.putExtra(key, value)
  3. startActivity(intent)를 작성한다.

 * 다이얼 혹은 바로 전화 걸기
  1. Manifest에 permission 추가.
    <uses-permission android:name="android.permission.CALL_PHONE" />
    <uses-permission android:name="android.permission.DIAL_PHONE" />
  2. "tel:" + 번호를 intent 정보로 넘긴다. 키 값은
    Intent("android.intent.action.DIAL", Uri.parse(uriString))
    Intent("android.intent.action.CALL", Uri.parse(uriString))
  3. startActivity(intent)를 작성한다.

 * startActivity 했을 때 하얀 화면만 나오는 경우
  1. preview에 보이는 화면의 height 값이 실제 앱이 올라가는 화면의 height 값하고 달라서 발생하는 현상. -> 절대값으로 잡지않고 상대값 혹은 wrap_content 등을 사용하여 해결
  2. 잘못된 onCreate를 사용했을 때, UI 초기화에 사용하는건 persistableState가 없는 것이므로, onCreate(savedInstanceState)인 onCreate를 사용해야 제대로 호출되고 view를 초기화 할 수 있다.

 * 코틀린에서의 물음표 
  코틀린은 안전한 null 사용 방법을 제공한다. ?를 사용하면 null 가능
  var A : string? = null
  A.length
  => Error 발생, A가 null이 될 수 있기 때문에 length 호출 불가. -> val length = if (A) != null) (A as String).length else -1 또는 A!!.length하면 강제로 호출 가능

 * warp_content(필요한 길이만 사용, 절대값 사용 가능) VS match_parent(해당 레이아웃을 가진 부모의 컨테이너 길이를 모두 사용)

 * lateinit
 // 참고 : https://kkangsnote.tistory.com/67

 * inflation (부풀리다.)
  - 레이아웃 xml에 명시한 것을 안드로이드 메모리에 생성하는 과정, xml에 씌여져 있는 view의 정의를 실제 view 객체로 만드는 역할.
  - xml 로 명시 안하고 java or kotlin으로 view를 만들 수 있다.
    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        LinearLayout linear = new LinearLayout(this);
        linear.setOrientation(LinearLayout.VERTICAL);
        linear.setBackgroundColor(Color.WHITE);
         
        TextView text = new TextView(this);
        text.setText("코드로 생성");
        text.setGravity(Gravity.CENTER);
        text.setTextColor(Color.RED);
        text.setTextSize(20);
         
        linear.addView(text); //부모 자식관계 설정과정
        setContentView(linear);
    }

  - complie time 후의 xml만 가능(runtime은 불가)
 
  // 참고 : https://aroundck.tistory.com/39
  // https://bryant.tistory.com/80

  * 'com.android.support libraries must use the exact same version specification'
  일부 라이브러리들의 버전이 일치해야하는데 일치하지 않아서 발생하는 현상.
  내 경우는 cardView 및 customtabs가 버전이 낮아서 발생함.
  버전 맞지 않는 라이브러리 마다 gradle dependency에 추가함.

 * reflection(::)
